<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CommandLineFluent</name>
    </assembly>
    <members>
        <member name="T:CommandLineFluent.Arguments.Converted`1">
            <summary>
            A converted value
            </summary>
            <typeparam name="C">The type of the converted value</typeparam>
        </member>
        <member name="P:CommandLineFluent.Arguments.Converted`1.ConvertedValue">
            <summary>
            The value converted to <typeparamref name="C"/>, if successful
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.Converted`1.ErrorMessage">
            <summary>
            An error message explaining why the value could not be converted to <typeparamref name="C"/>
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.Converted`1.Successful">
            <summary>
            Whether or not the conversion was successful
            </summary>
        </member>
        <member name="M:CommandLineFluent.Arguments.Converted`1.#ctor(`0)">
            <summary>
            Successfully converted the value
            </summary>
        </member>
        <member name="M:CommandLineFluent.Arguments.Converted`1.#ctor(`0,System.String)">
            <summary>
            Failed to convert the value
            </summary>
        </member>
        <member name="T:CommandLineFluent.Arguments.DependencyRule`2">
            <summary>
            Defines a single rule of a FluentRelationship.
            </summary>
            <typeparam name="T">The class</typeparam>
            <typeparam name="V">The value</typeparam>
        </member>
        <member name="P:CommandLineFluent.Arguments.DependencyRule`2.Requiredness">
            <summary>
            Does this rule say it's required, or must NOT appear
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.DependencyRule`2.TargetProperty">
            <summary>
            The target property to use when evaluating this rule
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.DependencyRule`2.Value">
            <summary>
            If IsEqualTo is used, this is the value this target property's value is compared to
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.DependencyRule`2.Predicate">
            <summary>
            The predicate used for this rule
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.DependencyRule`2.AppliesWhenPredicate">
            <summary>
            This rule applies when the predicate returns this value
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.DependencyRule`2.ErrorMessage">
            <summary>
            The error message when this rule is violated
            </summary>
        </member>
        <member name="M:CommandLineFluent.Arguments.DependencyRule`2.ThrowIfPredicateNotNull">
            <summary>
            A helper validation method that throws an exception if a DependencyRule gets configured twice
            </summary>
        </member>
        <member name="M:CommandLineFluent.Arguments.DependencyRule`2.IsEqualTo(`1)">
            <summary>
            Configures the dependency rule to apply when the property specified prior is equal to the provided value
            </summary>
            <param name="value">The value to which the property value has to equal for the rule to apply</param>
        </member>
        <member name="M:CommandLineFluent.Arguments.DependencyRule`2.IsNotEqualTo(`1)">
            <summary>
            Configures the dependency rule to apply when the property specified prior is not equal to the provided value
            </summary>
            <param name="value">The value to which the property value must not equal for the rule to apply</param>
        </member>
        <member name="M:CommandLineFluent.Arguments.DependencyRule`2.When(System.Func{`1,System.Boolean})">
            <summary>
            Configures the dependency rule to apply when the provided predicate evaluates to true
            </summary>
            <param name="predicate">The predicate which determines whether or not this rule applies</param>
        </member>
        <member name="M:CommandLineFluent.Arguments.DependencyRule`2.WhenNot(System.Func{`1,System.Boolean})">
            <summary>
            Configures the dependency rule to apply when the provided predicate evaluates to false
            </summary>
            <param name="predicate">The predicate which determines whether or not this rule applies</param>
        </member>
        <member name="M:CommandLineFluent.Arguments.DependencyRule`2.IsNull">
            <summary>
            Configures the dependency rule to apply when the property specified prior is null
            </summary>
        </member>
        <member name="M:CommandLineFluent.Arguments.DependencyRule`2.IsNotNull">
            <summary>
            Configures the dependency rule to apply when the property specified prior is not null
            </summary>
        </member>
        <member name="M:CommandLineFluent.Arguments.DependencyRule`2.WithErrorMessage(System.String)">
            <summary>
            Configures the error message to show when this rule is violated
            </summary>
            <param name="errorMessage"></param>
        </member>
        <member name="M:CommandLineFluent.Arguments.DependencyRule`2.DoesSatifyRule(`0,System.Boolean)">
            <summary>
            You don't need to call this; but this checks that the specified property of an object
            of type T satisfies the rule, given whether or not the FluentArgument on which this rule was configured
            had the string appear during parsing or not
            </summary>
            <param name="obj">The object</param>
            <param name="didAppear">If a string appeared during parsing</param>
        </member>
        <member name="M:CommandLineFluent.Arguments.DependencyRule`2.Validate">
            <summary>
            Validates this rule. Returns an Error if something is invalid, or null otherwise.
            </summary>
        </member>
        <member name="T:CommandLineFluent.Arguments.FluentArgument">
            <summary>
            A single argument on the command line. Can be a Switch, Option, or Value
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.FluentArgument.Name">
            <summary>
            A human-readable name which describes this
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.FluentArgument.HelpText">
            <summary>
            The Help Text to be shown to the user associated with this argument
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.FluentArgument.GotValue">
            <summary>
            True if the FluentArgument got a value from parsing arguments, false otherwise.
            Returns false if the 
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.FluentArgument.TargetProperty">
            <summary>
            The property that this argument maps to
            </summary>
        </member>
        <member name="T:CommandLineFluent.Arguments.FluentDependencies`2">
            <summary>
            Defines a relationship between a FluentArgument and a property of the target object.
            It allows you to specify that certain FluentArguments are only required under certain circumstances.
            </summary>
            <typeparam name="T">The class of the property which this FluentRelationship is for</typeparam>
            <typeparam name="C">The type of the property</typeparam>
        </member>
        <member name="P:CommandLineFluent.Arguments.FluentDependencies`2.Rules">
            <summary>
            The rules which make up this relationship
            </summary>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentDependencies`2.RequiredIf``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Specifies that a property of type <typeparamref name="V"/> of an object of type <typeparamref name="T"/>
            is required to be provided under specific circumstances.
            </summary>
            <typeparam name="V">The type of the property</typeparam>
            <param name="expression">The property that is required</param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentDependencies`2.MustNotAppearIf``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Specifies that a property of type <typeparamref name="V"/> of an object of type <typeparamref name="T"/>
            is required to NOT be provided under specific circumstances.
            </summary>
            <typeparam name="V">The type of the property</typeparam>
            <param name="expression">The property that is required</param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentDependencies`2.Validate">
            <summary>
            Validates this rule. Returns an Error for each invalid thing.
            </summary>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentDependencies`2.EvaluateRelationship(`0,System.Boolean,CommandLineFluent.Arguments.FluentArgumentType)">
            <summary>
            Returns null if all rules of the relationship have been respected, and an Error otherwise.
            </summary>
            <param name="obj">The object to check</param>
            <param name="wasValueProvided">Whether or not the FluentArgument received a value from parsing</param>
            <param name="fluentArgumentType">The type of argument, used to return the correct error code</param>
        </member>
        <member name="T:CommandLineFluent.Arguments.FluentManyValues`2">
            <summary>
            Captures all lone values, such as: Foo.exe Value1 -t someswitch Value2 Value3. All 3 values there would be captured as an array: [Value1, Value2, Value3].
            Use this when you want to consume an indeterminate number of values, regardless of their position.
            </summary>
            <typeparam name="T">The class of the property to which this argument maps</typeparam>
            <typeparam name="C">The type of the property this argument will set</typeparam>
        </member>
        <member name="P:CommandLineFluent.Arguments.FluentManyValues`2.IgnoredPrefixes">
            <summary>
            The prefixes that are ignored when capturing values. This is useful if you use a consistent prefixing scheme,
            and want to avoid capturing possible user typos; an error will be thrown instead of using it as a value.
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.FluentManyValues`2.Required">
            <summary>
            Whether or not at least 1 value is required. By default, it is required.
            If null, then Dependencies will be used to determine whether or not these Values are required.
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.FluentManyValues`2.DefaultValue">
            <summary>
            If not required, this is the default value used when no Values are provided
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.FluentManyValues`2.Dependencies">
            <summary>
            Dependencies on other properties which dictate whether or not this is required.
            </summary>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentManyValues`2.SetValue(`0,System.String[])">
            <summary>
            Attempts to set the value of the target property of the target object to the provided value. Uses any converter/validator provided.
            Order is: Validate, Convert, Assign.
            You shouldn't call this, Parse will automatically invoke this with appropriate values.
            </summary>
            <param name="target">The instance of <typeparamref name="T"/> on which to set the property</param>
            <param name="values">The raw values of all arguments found. If necessary, will be converted to the <typeparamref name="C"/> using the Converter set</param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentManyValues`2.ForProperty(System.Linq.Expressions.Expression{System.Func{`0,`1}})">
            <summary>
            Configures this Value to set the provided property of <typeparamref name="T"/>.
            </summary>
            <param name="expression">The property to set</param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentManyValues`2.IsRequired">
            <summary>
            Configures at least 1 Value to be required. By default, Values are required unless you use IsOptional.
            </summary>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentManyValues`2.IsOptional(`1)">
            <summary>
            Configures these Values as optional, with a default value when not provided.
            If you want to use ConditionallyRequired(), use WithDefaultValue instead to specify a fallback value.
            </summary>
            <param name="defaultValue">The value to use as a default value when no Values are provided. If not provided, this is the default value for <typeparamref name="C"/></param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentManyValues`2.WithDefaultValue(`1)">
            <summary>
            Configures a default value without specifying that these Values are optional. Use this instead of IsOptional when you use ConditionallyRequired()
            </summary>
            <param name="defaultValue">The value to use as a default when nothing else has been provided</param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentManyValues`2.WithHelpText(System.String)">
            <summary>
            Configures these Values to show the provided Help Text.
            </summary>
            <param name="helpText">The help text for these Values</param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentManyValues`2.WithName(System.String)">
            <summary>
            Configures these Values to have the provided human-readable name.
            By default this is used to produce Usage Text
            </summary>
            <param name="name">The human-readable name</param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentManyValues`2.WithConverter(System.Func{System.String[],CommandLineFluent.Arguments.Converted{`1}})">
            <summary>
            The converter to invoke on the argument value before assigning it to the property of <typeparamref name="T"/>.
            If not provided, no converter will be used.
            The converter is considered to have failed if it throws an exception, or if the error message is not null.
            In all other cases, it is considered successful.
            </summary>
            <param name="converter">A convert that converts a string[] to <typeparamref name="C"/></param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentManyValues`2.WithValidator(System.Func{System.String[],System.String})">
            <summary>
            The validator to invoke on the argument value before it is converted. This is mainly useful if you're
            not converting the string, and just need to validate it.
            The validator is considered to have succeeded if the returned string is null. If the returned string is not null,
            it is considered to have failed and the returned string is used as the error message.
            </summary>
            <param name="validator">The validator that validates the raw values</param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentManyValues`2.IgnorePrefixes(System.String[])">
            <summary>
            Prefixes to ignore when parsing values. Useful when your Options and Switches have a consistent prefix, and you
            don't want mistyped Options and Switches being parsed as Values.
            </summary>
            <param name="prefixes">The prefixes to ignore</param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentManyValues`2.WithDependencies(System.Action{CommandLineFluent.Arguments.FluentDependencies{`0,`1}})">
            <summary>
            Configures this ManyValue to only be required or must not appear under certain circumstances.
            If any rule is violated, parsing is considered to have failed. If all rules pass, then parsing is considered to have succeeded.
            You can specify that the user has to provide this Value depending upon the value of other properties (after parsing, validation, and conversion)
            </summary>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentManyValues`2.EvaluateDependencies(`0)">
            <summary>
            Checks to make sure that all dependencies are respected. If they are not, returns an Error
            describing the first dependency that was violated.
            If no dependencies have been set up, returns null.
            </summary>
            <param name="obj">The object to check</param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentManyValues`2.Validate">
            <summary>
            Validates this FluentArgument, returning an Error object if something is invalid.
            </summary>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentManyValues`2.ThrowIfRequirednessAlreadyConfigured">
            <summary>
            Throws if _configuredRequiredness is true.
            </summary>
        </member>
        <member name="T:CommandLineFluent.Arguments.FluentOption`2">
            <summary>
            An option with one value, supplied like -t Value
            </summary>
            <typeparam name="T">The class of the property to which this argument maps</typeparam>
            <typeparam name="C">The type of the property this argument will set</typeparam>
        </member>
        <member name="P:CommandLineFluent.Arguments.FluentOption`2.ShortName">
            <summary>
            Short name for this Option
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.FluentOption`2.LongName">
            <summary>
            Long name for this Option
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.FluentOption`2.Required">
            <summary>
            Whether or not this Option is required to be included. By default, it is required.
            If null, then Dependencies will be used to determine whether or not this Option is required.
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.FluentOption`2.DefaultValue">
            <summary>
            If not required, this is the default value used when the Option is not provided
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.FluentOption`2.Dependencies">
            <summary>
            Dependencies on other properties which dictate whether or not this is required.
            </summary>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentOption`2.SetValue(`0,System.String)">
            <summary>
            Attempts to set the value of the target property of the target object to the provided value. Uses any converter/validator provided.
            Order is: Validate, Convert, Assign.
            You shouldn't call this, Parse will automatically invoke this with appropriate values.
            </summary>
            <param name="target">The instance of <typeparamref name="T"/> on which to set the property</param>
            <param name="value">The raw value of the argument. If necessary, will be converted to the <typeparamref name="C"/> using the Converter set</param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentOption`2.ForProperty(System.Linq.Expressions.Expression{System.Func{`0,`1}})">
            <summary>
            Configures this Option to set the provided property of <typeparamref name="T"/>.
            </summary>
            <param name="expression">The property to set</param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentOption`2.IsRequired">
            <summary>
            Configures this Option to be required. By default, Options are required unless you use IsOptional.
            </summary>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentOption`2.IsOptional(`1)">
            <summary>
            Configures this Option as optional, with a default value when not provided.
            If you are setting up Conditional requirements, use WithDefaultValue instead to specify a fallback value.
            </summary>
            <param name="defaultValue">The value to use as a default value when this Option is not provided. If not provided, this is the default value for <typeparamref name="C"/></param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentOption`2.WithDefaultValue(`1)">
            <summary>
            Configures a default value without specifying that this Option is optional. Use this instead of IsOptional when you use ConditionallyRequired()
            </summary>
            <param name="defaultValue">The value to use as a default when nothing else has been provided</param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentOption`2.WithHelpText(System.String)">
            <summary>
            Configures this Option to show the provided Help Text.
            </summary>
            <param name="helpText">The help text for this Option</param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentOption`2.WithName(System.String)">
            <summary>
            Configures this Option to have the provided human-readable name.
            By default this is used to produce Usage Text
            </summary>
            <param name="name">The human-readable name</param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentOption`2.WithConverter(System.Func{System.String,CommandLineFluent.Arguments.Converted{`1}})">
            <summary>
            The converter to invoke on the provided value before assigning it to the property of <typeparamref name="T"/>.
            If not provided, no converter will be used. If this Option is not provided, the converter will not be invoked.
            The converter is considered to have failed if it throws an exception, or if the error message is not null.
            In all other cases, it is considered successful.
            </summary>
            <param name="converter">A convert that converts a string to <typeparamref name="C"/></param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentOption`2.WithValidator(System.Func{System.String,System.String})">
            <summary>
            The validator to invoke on the provided value before it is converted. This is mainly useful if you're
            not converting the string, and just need to validate it. If this Option is not provided, the validator will not be invoked.
            The validator is considered to have succeeded if the returned string is null. If the returned string is not null,
            it is considered to have failed and the returned string is used as the error message.
            </summary>
            <param name="validator">The validator that validates the raw value</param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentOption`2.ShortAndLongName">
            <summary>
            The short and long name joined with a |
            </summary>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentOption`2.WithDependencies(System.Action{CommandLineFluent.Arguments.FluentDependencies{`0,`1}})">
            <summary>
            Configures this Option to only be required or must not appear under certain circumstances.
            If any rule is violated, parsing is considered to have failed. If all rules pass, then parsing is considered to have succeeded.
            You can specify that the user has to provide this Value depending upon the value of other properties (after parsing, validation, and conversion)
            </summary>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentOption`2.EvaluateDependencies(`0)">
            <summary>
            Checks to make sure that all dependencies are respected. If they are not, returns an Error
            describing the first dependency that was violated.
            If no dependencies have been set up, returns null.
            </summary>
            <param name="obj">The object to check</param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentOption`2.Validate">
            <summary>
            Validates this FluentArgument, returning an Error object if something is invalid.
            </summary>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentOption`2.ThrowIfRequirednessAlreadyConfigured">
            <summary>
            Throws if _configuredRequiredness is true.
            </summary>
        </member>
        <member name="T:CommandLineFluent.Arguments.FluentSwitch`2">
            <summary>
            A switch toggled on or off, supplied like -s
            </summary>
            <typeparam name="T">The class of the property to which this argument maps</typeparam>
            <typeparam name="C">The type of the property this argument will set</typeparam>
        </member>
        <member name="P:CommandLineFluent.Arguments.FluentSwitch`2.ShortName">
            <summary>
            Short name for this switch
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.FluentSwitch`2.LongName">
            <summary>
            Long name for this switch
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.FluentSwitch`2.DefaultValue">
            <summary>
            If the switch is not present, this is the default value to use
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.FluentSwitch`2.Dependencies">
            <summary>
            Dependencies on other properties which dictate whether or not this is required.
            </summary>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentSwitch`2.SetValue(`0,System.Boolean)">
            <summary>
            Attempts to set the value of the target property of the target object to the provided value. Uses any converter/validator provided.
            Order is: Validate, Convert, Assign.
            You shouldn't call this, Parse will automatically invoke this with appropriate values.
            </summary>
            <param name="target">The instance of <typeparamref name="T"/> on which to set the property</param>
            <param name="value">If the switch is provided, this is true. Otherwise, false. If necessary, will be converted to type <typeparamref name="C"/> using the Converter</param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentSwitch`2.ForProperty(System.Linq.Expressions.Expression{System.Func{`0,`1}})">
            <summary>
            Configures this Switch to set the provided property of <typeparamref name="T"/>. Property has the type of <typeparamref name="C"/>.
            </summary>
            <param name="expression">The property to set</param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentSwitch`2.WithHelpText(System.String)">
            <summary>
            Configures this Switch to show the provided Help Text.
            </summary>
            <param name="helpText">The help text for this Switch</param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentSwitch`2.WithDefaultValue(`1)">
            <summary>
            Configures this Switch to use a specific value when it is not provided
            </summary>
            <param name="defaultValue">The value to use as a default value when this Switch is not provided.</param>
            <returns></returns>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentSwitch`2.WithConverter(System.Func{System.Boolean,CommandLineFluent.Arguments.Converted{`1}})">
            <summary>
            The converter to invoke on the provided value before assigning it to the property of <typeparamref name="T"/>.
            If not provided, no converter will be used. If this Option is not provided, the converter will not be invoked.
            The converter is considered to have failed if it throws an exception, or if the error message is not null.
            In all other cases, it is considered successful.
            </summary>
            <param name="converter">A convert that converts a bool to <typeparamref name="C"/></param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentSwitch`2.ShortAndLongName">
            <summary>
            The short and long name joined with a |
            </summary>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentSwitch`2.WithDependencies(System.Action{CommandLineFluent.Arguments.FluentDependencies{`0,`1}})">
            <summary>
            Configures this Switch to only be required or must not appear under certain circumstances.
            If any rule is violated, parsing is considered to have failed. If all rules pass, then parsing is considered to have succeeded.
            You can specify that the user has to provide this Value depending upon the value of other properties (after parsing, validation, and conversion)
            </summary>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentSwitch`2.EvaluateDependencies(`0)">
            <summary>
            Checks to make sure that all dependencies are respected. If they are not, returns an Error
            describing the first dependency that was violated.
            If no dependencies have been set up, returns null.
            </summary>
            <param name="obj">The object to check</param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentSwitch`2.Validate">
            <summary>
            Validates this FluentArgument, returning an Error object if something is invalid.
            </summary>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentSwitch`2.ThrowIfRequirednessAlreadyConfigured">
            <summary>
            Throws if _configuredRequiredness is true.
            </summary>
        </member>
        <member name="T:CommandLineFluent.Arguments.FluentValue`2">
            <summary>
            A lone value, such as: Foo.exe MyFile.
            </summary>
            <typeparam name="T">The class of the property to which this argument maps</typeparam>
            <typeparam name="C">The type of the property this argument will set</typeparam>
        </member>
        <member name="P:CommandLineFluent.Arguments.FluentValue`2.Required">
            <summary>
            Whether or not this Value is required to be provided. By default, it is required.
            If null, then Dependencies will be used to determine whether or not this Value is required.
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.FluentValue`2.DefaultValue">
            <summary>
            If not required, this is the default value used when the Value is not provided
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.FluentValue`2.Dependencies">
            <summary>
            Dependencies on other properties which dictate whether or not this is required.
            </summary>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentValue`2.SetValue(`0,System.String)">
            <summary>
            Attempts to set the value of the target property of the target object to the provided value. Uses any converter/validator provided.
            Order is: Validate, Convert, Assign.
            You shouldn't call this, Parse will automatically invoke this with appropriate values.
            </summary>
            <param name="target">The instance of <typeparamref name="T"/> on which to set the property</param>
            <param name="value">The raw value of the argument. If necessary, will be converted to the <typeparamref name="C"/> using the Converter set</param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentValue`2.ForProperty(System.Linq.Expressions.Expression{System.Func{`0,`1}})">
            <summary>
            Configures this Value to set the provided property of <typeparamref name="T"/>.
            </summary>
            <param name="expression">The property to set</param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentValue`2.IsRequired">
            <summary>
            Configures this Value to be required. By default, Values are required unless you use IsOptional.
            </summary>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentValue`2.IsOptional(`1)">
            <summary>
            Configures this Value as optional, with a default value when not provided. Note that if the 0th Value is optional and the 1st Value is required,
            and you provide a single value, that single value will map to the 0th Value and throw an error because the 1st Value was missing. It's recommended you use this judiciously.
            If you are setting up Conditional requirements, use WithDefaultValue instead to specify a fallback value.
            </summary>
            <param name="defaultValue">The value to use as a default value when this Value is not provided. If not provided, this is the default value for <typeparamref name="C"/></param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentValue`2.WithDefaultValue(`1)">
            <summary>
            Configures a default value without specifying that this Value is optional. Use this instead of IsOptional when you use ConditionallyRequired()
            </summary>
            <param name="defaultValue">The value to use as a default when nothing else has been provided</param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentValue`2.WithHelpText(System.String)">
            <summary>
            Configures this Value to show the provided Help Text.
            </summary>
            <param name="helpText">The help text for this Value</param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentValue`2.WithName(System.String)">
            <summary>
            Configures this Value to have the provided human-readable name.
            By default this is used to produce Usage Text
            </summary>
            <param name="name">The human-readable name</param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentValue`2.WithConverter(System.Func{System.String,CommandLineFluent.Arguments.Converted{`1}})">
            <summary>
            The converter to invoke on the argument value before assigning it to the property of <typeparamref name="T"/>.
            If not provided, no converter will be used.
            The converter is considered to have failed if it throws an exception, or if the error message is not null.
            In all other cases, it is considered successful.
            </summary>
            <param name="converter">A convert that converts a string to <typeparamref name="C"/></param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentValue`2.WithValidator(System.Func{System.String,System.String})">
            <summary>
            The validator to invoke on the argument value before it is converted. This is mainly useful if you're
            not converting the string, and just need to validate it.
            The validator is considered to have succeeded if the returned string is null. If the returned string is not null,
            it is considered to have failed and the returned string is used as the error message.
            </summary>
            <param name="validator">The validator that validates the raw value</param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentValue`2.WithDependencies(System.Action{CommandLineFluent.Arguments.FluentDependencies{`0,`1}})">
            <summary>
            Configures this Value to only be required or must not appear under certain circumstances.
            If any rule is violated, parsing is considered to have failed. If all rules pass, then parsing is considered to have succeeded.
            You can specify that the user has to provide this Value depending upon the value of other properties (after parsing, validation, and conversion)
            </summary>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentValue`2.EvaluateDependencies(`0)">
            <summary>
            Checks to make sure that all dependencies are respected. If they are not, returns an Error
            describing the first dependency that was violated.
            If no dependencies have been set up, returns null.
            </summary>
            <param name="obj">The object to check</param>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentValue`2.Validate">
            <summary>
            Validates this FluentArgument, returning an Error object if something is invalid.
            </summary>
        </member>
        <member name="M:CommandLineFluent.Arguments.FluentValue`2.ThrowIfRequirednessAlreadyConfigured">
            <summary>
            Throws if _configuredRequiredness is true.
            </summary>
        </member>
        <member name="T:CommandLineFluent.Arguments.IDependencyRule`1">
            <summary>
            Defines a single rule of a FluentRelationship.
            </summary>
            <typeparam name="T">The class</typeparam>
        </member>
        <member name="M:CommandLineFluent.Arguments.IDependencyRule`1.DoesSatifyRule(`0,System.Boolean)">
            <summary>
            You don't need to call this; but this checks that the specified property of an object
            of type T satisfies the rule, given whether or not the FluentArgument on which this rule was configured
            had the string appear during parsing or not
            </summary>
            <param name="obj">The object</param>
            <param name="didAppear">If a string appeared during parsing</param>
        </member>
        <member name="P:CommandLineFluent.Arguments.IDependencyRule`1.ErrorMessage">
            <summary>
            The error message when this rule is violated
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.IDependencyRule`1.Requiredness">
            <summary>
            Does this rule say it's required, or must NOT appear
            </summary>
        </member>
        <member name="M:CommandLineFluent.Arguments.IDependencyRule`1.Validate">
            <summary>
            Validates this rule. Returns an Error if something is invalid, or null otherwise.
            </summary>
        </member>
        <member name="T:CommandLineFluent.Arguments.IFluentArgument">
            <summary>
            A single argument on the command line. Can be a Switch, Option, or Value
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.IFluentArgument.Name">
            <summary>
            A human-readable name which describes this
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.IFluentArgument.HelpText">
            <summary>
            The Help Text to be shown to the user associated with this argument
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.IFluentArgument.GotValue">
            <summary>
            True if the FluentArgument got a value from parsing arguments, false otherwise.
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.IFluentArgument.TargetProperty">
            <summary>
            The property that this argument maps to
            </summary>
        </member>
        <member name="T:CommandLineFluent.Arguments.IFluentManyValues">
            <summary>
            Captures all lone values, such as: Foo.exe Value1 -t someswitch Value2 Value3. All 3 values there would be captured as an array: [Value1, Value2, Value3].
            Use this when you want to consume an indeterminate number of values, regardless of their position.
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.IFluentManyValues.IgnoredPrefixes">
            <summary>
            The prefixes that are ignored when capturing values. This is useful if you use a consistent prefixing scheme,
            and want to avoid capturing possible user typos; an error will be thrown instead of using it as a value.
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.IFluentManyValues.Required">
            <summary>
            Whether or not at least 1 value is required. By default, it is required.
            If null, then Dependencies will be used to determine whether or not these Values are required.
            </summary>
        </member>
        <member name="T:CommandLineFluent.Arguments.IFluentOption">
            <summary>
            An option with one value, supplied like -t Value
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.IFluentOption.ShortName">
            <summary>
            The Short Name for this FluentOption
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.IFluentOption.LongName">
            <summary>
            The Long Name for this FluentOption
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.IFluentOption.Required">
            <summary>
            Whether or not this Option is required to be included. By default, it is required.
            If null, then Dependencies will be used to determine whether or not this Option is required.
            </summary>
        </member>
        <member name="M:CommandLineFluent.Arguments.IFluentOption.ShortAndLongName">
            <summary>
            The short and long name joined with a |
            </summary>
        </member>
        <member name="T:CommandLineFluent.Arguments.IFluentSettable`2">
            <summary>
            A Fluent Argument that is able to have its value set to something
            </summary>
            <typeparam name="T">The type of the target class whose property will be set</typeparam>
            <typeparam name="V">The type of the value provided. May be converted to something else</typeparam>
        </member>
        <member name="M:CommandLineFluent.Arguments.IFluentSettable`2.SetValue(`0,`1)">
            <summary>
            Sets a property of object <typeparamref name="T"/> to the value of <typeparamref name="V"/>.
            There may or may not be a converter set up to translate <paramref name="value"/> into something else
            </summary>
            <param name="target">The object on which to set a property</param>
            <param name="value">The value to set the property to (before any conversion)</param>
        </member>
        <member name="M:CommandLineFluent.Arguments.IFluentSettable`2.Validate">
            <summary>
            Returns an Error for each invalid thing.
            </summary>
        </member>
        <member name="M:CommandLineFluent.Arguments.IFluentSettable`2.EvaluateDependencies(`0)">
            <summary>
            Checks to make sure that all dependencies are respected. If they are not, returns an Error
            describing the first dependency that was violated.
            If no dependencies have been set up, returns null.
            </summary>
            <param name="obj">The object to check</param>
        </member>
        <member name="T:CommandLineFluent.Arguments.IFluentSwitch">
            <summary>
            A switch toggled on or off, supplied like -s
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.IFluentSwitch.ShortName">
            <summary>
            The Short Name for this FluentSwitch
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.IFluentSwitch.LongName">
            <summary>
            The Long Name for this FluentSwitch
            </summary>
        </member>
        <member name="M:CommandLineFluent.Arguments.IFluentSwitch.ShortAndLongName">
            <summary>
            The short and long name joined with a |
            </summary>
        </member>
        <member name="T:CommandLineFluent.Arguments.IFluentValue">
            <summary>
            A value that is supplied like foo.exe MyValue
            </summary>
        </member>
        <member name="P:CommandLineFluent.Arguments.IFluentValue.Required">
            <summary>
            Whether or not this Value is required to be provided. By default, it is required.
            If null, then Dependencies will be used to determine whether or not this Value is required.
            </summary>
        </member>
        <member name="T:CommandLineFluent.Arguments.Requiredness">
            <summary>
            Whether 
            </summary>
        </member>
        <member name="F:CommandLineFluent.Arguments.Requiredness.Required">
            <summary>
            Required to appear
            </summary>
        </member>
        <member name="F:CommandLineFluent.Arguments.Requiredness.MustNotAppear">
            <summary>
            Required to NOT appear
            </summary>
        </member>
        <member name="T:CommandLineFluent.Conversion.Converters">
            <summary>
            Has some commonly-used converters. For those that just take one string, you can do this:
            verb.WithConverter(Converters.ToInt32)
            </summary>
        </member>
        <member name="M:CommandLineFluent.Conversion.Converters.ToBool(System.String)">
            <summary>
            Converts the provided string to a bool.
            Uses bool.TryParse()
            </summary>
            <param name="s">The string to convert</param>
        </member>
        <member name="M:CommandLineFluent.Conversion.Converters.ToNullableBool(System.String)">
            <summary>
            Converts the provided string to a nullable bool. Identical to ToBool, but can be used with Optional parameters.
            </summary>
            <param name="s">The string to convert</param>
        </member>
        <member name="M:CommandLineFluent.Conversion.Converters.ToBoolYesNo(System.String)">
            <summary>
            Converts the provided string to a bool. y, yes, or true will convert to true. n, no, or false will convert to false.
            Case insensitive.
            </summary>
            <param name="s">The string to convert</param>
        </member>
        <member name="M:CommandLineFluent.Conversion.Converters.ToNullableBoolYesNo(System.String)">
            <summary>
            Converts the provided string to a nullable bool. Identical to ToBoolYesNo, but can be used with Optional parameters.
            </summary>
            <param name="s">The string to convert</param>
        </member>
        <member name="M:CommandLineFluent.Conversion.Converters.ToInt(System.String)">
            <summary>
            Converts the provided string to an int.
            Uses int.TryParse()
            </summary>
            <param name="s">The string to convert</param>
        </member>
        <member name="M:CommandLineFluent.Conversion.Converters.ToNullableInt(System.String)">
            <summary>
            Converts the provided string to a nullable int. Identical to ToInt, but can be used with Optional parameters.
            </summary>
            <param name="s">The string to convert</param>
        </member>
        <member name="M:CommandLineFluent.Conversion.Converters.ToUInt(System.String)">
            <summary>
            Converts the provided string to an uint.
            Uses uint.TryParse()
            </summary>
            <param name="s">The string to convert</param>
        </member>
        <member name="M:CommandLineFluent.Conversion.Converters.ToNullableUInt(System.String)">
            <summary>
            Converts the provided string to a nullable uint. Identical to ToUInt, but can be used with Optional parameters.
            </summary>
            <param name="s">The string to convert</param>
        </member>
        <member name="M:CommandLineFluent.Conversion.Converters.ToLong(System.String)">
            <summary>
            Converts the provided string to a long.
            Uses long.TryParse()
            </summary>
            <param name="s">The string to convert</param>
        </member>
        <member name="M:CommandLineFluent.Conversion.Converters.ToNullableLong(System.String)">
            <summary>
            Converts the provided string to a nullable long. Identical to ToLong, but can be used with Optional parameters.
            </summary>
            <param name="s">The string to convert</param>
        </member>
        <member name="M:CommandLineFluent.Conversion.Converters.ToULong(System.String)">
            <summary>
            Converts the provided string to an ulong.
            Uses ulong.TryParse()
            </summary>
            <param name="s">The string to convert</param>
        </member>
        <member name="M:CommandLineFluent.Conversion.Converters.ToNullableULong(System.String)">
            <summary>
            Converts the provided string to a nullable ulong. Identical to ToULong, but can be used with Optional parameters.
            </summary>
            <param name="s">The string to convert</param>
        </member>
        <member name="M:CommandLineFluent.Conversion.Converters.ToDouble(System.String)">
            <summary>
            Converts the provided string to a double.
            Uses double.TryParse()
            </summary>
            <param name="s">The string to convert</param>
        </member>
        <member name="M:CommandLineFluent.Conversion.Converters.ToNullableDouble(System.String)">
            <summary>
            Converts the provided string to a nullable double. Identical to ToDouble, but can be used with Optional parameters.
            </summary>
            <param name="s">The string to convert</param>
        </member>
        <member name="M:CommandLineFluent.Conversion.Converters.ToDecimal(System.String)">
            <summary>
            Converts the provided string to a decimal.
            Uses decimal.TryParse()
            </summary>
            <param name="s">The string to convert</param>
        </member>
        <member name="M:CommandLineFluent.Conversion.Converters.ToNullableDecimal(System.String)">
            <summary>
            Converts the provided string to a nullable decimal. Identical to ToDecimal, but can be used with Optional parameters.
            </summary>
            <param name="s">The string to convert</param>
        </member>
        <member name="M:CommandLineFluent.Conversion.Converters.ToDate(System.String)">
            <summary>
            Converts the provided string to a Date, at midnight. Returns an error if a Time component was specified.
            Uses DateTime.TryParse()
            </summary>
            <param name="s">The string to convert</param>
        </member>
        <member name="M:CommandLineFluent.Conversion.Converters.ToNullableDate(System.String)">
            <summary>
            Converts the provided string to a nullable DateTime. Identical to ToDate, but can be used with Optional parameters.
            </summary>
            <param name="s">The string to convert</param>
        </member>
        <member name="M:CommandLineFluent.Conversion.Converters.ToDateTime(System.String)">
            <summary>
            Converts the provided string to a DateTime.
            Uses DateTime.TryParse()
            </summary>
            <param name="s">The string to convert</param>
        </member>
        <member name="M:CommandLineFluent.Conversion.Converters.ToNullableDateTime(System.String)">
            <summary>
            Converts the provided string to a nullable DateTime. Identical to ToDateTime, but can be used with Optional parameters.
            </summary>
            <param name="s">The string to convert</param>
        </member>
        <member name="M:CommandLineFluent.Conversion.Converters.ToEnum``1(System.String)">
            <summary>
            Converts the provided string to an Enum.
            Uses Enum.TryParse&lt;<typeparamref name="T"/>>()
            </summary>
            <typeparam name="T">The type of the enum to parse</typeparam>
            <param name="s">The string to convert</param>
        </member>
        <member name="M:CommandLineFluent.Conversion.Converters.Split(System.String,System.Char[])">
            <summary>
            Splits the string into multiple strings based on separators.
            Uses s.Split()
            </summary>
            <param name="s">The string to split</param>
            <param name="separator">The separators to use</param>
        </member>
        <member name="M:CommandLineFluent.Conversion.Converters.Split(System.String,System.Char[],System.Int32)">
            <summary>
            Splits the string into multiple strings based on separators.
            Uses s.Split()
            </summary>
            <param name="s">The string to split</param>
            <param name="separator">The separators to use</param>
            <param name="count">The maximum number of substrings to return</param>
        </member>
        <member name="M:CommandLineFluent.Conversion.Converters.Split(System.String,System.Char[],System.StringSplitOptions)">
            <summary>
            Splits the string into multiple strings based on separators.
            Uses s.Split()
            </summary>
            <param name="s">The string to split</param>
            <param name="separator">The separators to use</param>
            <param name="options">System.StringSplitOptions.RemoveEmptyEntries to omit empty array elements from the array returned; or System.StringSplitOptions.None to include empty array
            elements in the array returned.</param>
        </member>
        <member name="M:CommandLineFluent.Conversion.Converters.Split(System.String,System.String[],System.StringSplitOptions)">
            <summary>
            Splits the string into multiple strings based on separators.
            Uses s.Split()
            </summary>
            <param name="s">The string to split</param>
            <param name="separator">The separators to use</param>
            <param name="options">System.StringSplitOptions.RemoveEmptyEntries to omit empty array elements from the array returned; or System.StringSplitOptions.None to include empty array
            elements in the array returned.</param>
        </member>
        <member name="M:CommandLineFluent.Conversion.Converters.Split(System.String,System.Char[],System.Int32,System.StringSplitOptions)">
            <summary>
            Splits the string into multiple strings based on separators.
            Uses s.Split()
            </summary>
            <param name="s">The string to split</param>
            <param name="separator">The separators to use</param>
            <param name="count">The maximum number of substrings to return</param>
            <param name="options">System.StringSplitOptions.RemoveEmptyEntries to omit empty array elements from the array returned; or System.StringSplitOptions.None to include empty array
            elements in the array returned.</param>
        </member>
        <member name="M:CommandLineFluent.Conversion.Converters.Split(System.String,System.String[],System.Int32,System.StringSplitOptions)">
            <summary>
            Splits the string into multiple strings based on separators.
            Uses s.Split()
            </summary>
            <param name="s">The string to split</param>
            <param name="separator">The separators to use</param>
            <param name="count">The maximum number of substrings to return</param>
            <param name="options">System.StringSplitOptions.RemoveEmptyEntries to omit empty array elements from the array returned; or System.StringSplitOptions.None to include empty array
            elements in the array returned.</param>
        </member>
        <member name="T:CommandLineFluent.Error">
            <summary>
            Represents an error which was encountered when parsing the command line arguments provided
            </summary>
        </member>
        <member name="P:CommandLineFluent.Error.Message">
            <summary>
            A human-readable error message
            </summary>
        </member>
        <member name="P:CommandLineFluent.Error.ShouldBeShownToUser">
            <summary>
            Whether or not this Error is relevant to the user and should be shown to them
            </summary>
        </member>
        <member name="P:CommandLineFluent.Error.ErrorCode">
            <summary>
            What exactly went wrong
            </summary>
        </member>
        <member name="P:CommandLineFluent.Error.Exception">
            <summary>
            Any exceptions thrown when parsing the value
            </summary>
        </member>
        <member name="M:CommandLineFluent.Error.#ctor(CommandLineFluent.ErrorCode,System.Boolean,System.String,System.Exception)">
            <summary>
            Creates a new instance of Error
            </summary>
            <param name="errorCode">The error code</param>
            <param name="shouldBeShownToUser">Whether or not this error should be displayed to the user</param>
            <param name="message">The message for this error</param>
            <param name="exception">The Exception that caused this error</param>
        </member>
        <member name="M:CommandLineFluent.Error.ToString">
            <summary>
            Converts this Error to a string. Contains ErrorCode, Message, and Exception.ToString()
            </summary>
        </member>
        <member name="T:CommandLineFluent.ErrorCode">
            <summary>
            Represents an error case
            </summary>
        </member>
        <member name="F:CommandLineFluent.ErrorCode.Ok">
            <summary>
            All is well, nothing went wrong
            </summary>
        </member>
        <member name="F:CommandLineFluent.ErrorCode.MissingRequiredValue">
            <summary>
            A required value was specified but the user did not provide it
            </summary>
        </member>
        <member name="F:CommandLineFluent.ErrorCode.MissingRequiredValues">
            <summary>
            Many required values were specified but the user did not provide at least 1
            </summary>
        </member>
        <member name="F:CommandLineFluent.ErrorCode.MissingRequiredOption">
            <summary>
            A required option was specified but the user did not provide it
            </summary>
        </member>
        <member name="F:CommandLineFluent.ErrorCode.TooManyValues">
            <summary>
            The user specified more values than we were expecting
            </summary>
        </member>
        <member name="F:CommandLineFluent.ErrorCode.OptionNotFound">
            <summary>
            The user specified an option which we were not expecting
            </summary>
        </member>
        <member name="F:CommandLineFluent.ErrorCode.SwitchNotFound">
            <summary>
            The user specified a switch which we were not expecting
            </summary>
        </member>
        <member name="F:CommandLineFluent.ErrorCode.UnexpectedEndOfArguments">
            <summary>
            We were expecting to find something more, e.g. A value after an option, but we did not
            </summary>
        </member>
        <member name="F:CommandLineFluent.ErrorCode.UnexpectedArgument">
            <summary>
            The user specified something we were not expecting
            </summary>
        </member>
        <member name="F:CommandLineFluent.ErrorCode.DuplicateOption">
            <summary>
            The user specified an option multiple times
            </summary>
        </member>
        <member name="F:CommandLineFluent.ErrorCode.DuplicateSwitch">
            <summary>
            The user specified a switch multiple times
            </summary>
        </member>
        <member name="F:CommandLineFluent.ErrorCode.OptionFailedValidation">
            <summary>
            The value that the user provided for an option failed validation
            </summary>
        </member>
        <member name="F:CommandLineFluent.ErrorCode.ValueFailedValidation">
            <summary>
            The value that the user provided for a value failed validation
            </summary>
        </member>
        <member name="F:CommandLineFluent.ErrorCode.ValuesFailedValidation">
            <summary>
            The values that the user provided for many values failed validation
            </summary>
        </member>
        <member name="F:CommandLineFluent.ErrorCode.OptionFailedConversion">
            <summary>
            The value that the user provided for an option failed conversion
            </summary>
        </member>
        <member name="F:CommandLineFluent.ErrorCode.ValueFailedConversion">
            <summary>
            The value that the user provided for a value failed conversion
            </summary>
        </member>
        <member name="F:CommandLineFluent.ErrorCode.ValuesFailedConversion">
            <summary>
            The values that the user provided for many values failed conversion
            </summary>
        </member>
        <member name="F:CommandLineFluent.ErrorCode.SwitchFailedConversion">
            <summary>
            The switch that the user specified failed conversion
            </summary>
        </member>
        <member name="F:CommandLineFluent.ErrorCode.InvalidVerb">
            <summary>
            The verb that the user specified was not a defined verb
            </summary>
        </member>
        <member name="F:CommandLineFluent.ErrorCode.NoVerbFound">
            <summary>
            The user didn't specify a verb, but we were expecting one
            </summary>
        </member>
        <member name="F:CommandLineFluent.ErrorCode.HelpRequested">
            <summary>
            The user requested help
            </summary>
        </member>
        <member name="F:CommandLineFluent.ErrorCode.ProgrammerError">
            <summary>
            This error code value indicates a bug in your program, you'll only see this ErrorCode when an exception is raised.
            </summary>
        </member>
        <member name="F:CommandLineFluent.ErrorCode.OptionMustNotBeProvided">
            <summary>
            An option must not be provided
            </summary>
        </member>
        <member name="F:CommandLineFluent.ErrorCode.MissingRequiredSwitch">
            <summary>
            A switch was required but was missing
            </summary>
        </member>
        <member name="F:CommandLineFluent.ErrorCode.SwitchMustNotBeProvided">
            <summary>
            A switch must not be provided
            </summary>
        </member>
        <member name="F:CommandLineFluent.ErrorCode.ValueMustNotBeProvided">
            <summary>
            A value must not be provided
            </summary>
        </member>
        <member name="F:CommandLineFluent.ErrorCode.MissingRequiredManyValues">
            <summary>
            Many values were required but were missing
            </summary>
        </member>
        <member name="F:CommandLineFluent.ErrorCode.ManyValuesMustNotBeProvided">
            <summary>
            Many values must not be provided
            </summary>
        </member>
        <member name="T:CommandLineFluent.FluentParser">
            <summary>
            Able to parse command line arguments (or other stuff, if suitable).
            To create one, you need to use FluentParserBuilder.
            I'd recommend keeping an instance of this if it's needed multiple times.
            </summary>
        </member>
        <member name="P:CommandLineFluent.FluentParser.Verbs">
            <summary>
            Verb names to the Verbs themselves.
            </summary>
        </member>
        <member name="P:CommandLineFluent.FluentParser.IsUsingVerbs">
            <summary>
            If true, the FluentParser has been set up to parse at least one verb.
            If false, the FluentParser has been set up to not parse any verbs, so it just parses arguments as-is.
            </summary>
        </member>
        <member name="P:CommandLineFluent.FluentParser.Config">
            <summary>
            The current configuration.
            </summary>
        </member>
        <member name="M:CommandLineFluent.FluentParser.#ctor(CommandLineFluent.FluentParserBuilder)">
            <summary>
            Creates a new instance of FluentParser
            </summary>
        </member>
        <member name="M:CommandLineFluent.FluentParser.Parse(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Parses the provided arguments. If AddVerb was used, the first argument is interpreted as the verb name, and the rest of them are parsed normally.
            If WithoutVerbs was used, all arguments are parsed normally.
            If an error is encountered, help/usage will be written automatically, if that has been configured. Usage and Description is written for all verbs if no
            verb was parsed, or if a specific verb was parsed, detailed help/usage is written for that verb.
            </summary>
            <param name="args">The arguments to parse</param>
        </member>
        <member name="M:CommandLineFluent.FluentParser.ParseAwaitable(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Parses the provided arguments. If AddVerb was used, the first argument is interpreted as the verb name, and the rest of them are parsed normally.
            If WithoutVerbs was used, all arguments are parsed normally.
            If an error is encountered, help/usage will be written automatically, if that has been configured. Usage and Description is written for all verbs if no
            verb was parsed, or if a specific verb was parsed, detailed help/usage is written for that verb.
            This will allow you to specify awaitable methods.
            </summary>
            <param name="args">The arguments to parse</param>
        </member>
        <member name="M:CommandLineFluent.FluentParser.WriteErrors(System.Collections.Generic.IEnumerable{CommandLineFluent.Error})">
            <summary>
            Writes the provided Errors.
            Does nothing if Config.WriteErrors is null.
            </summary>
            <param name="errors">The errors to write</param>
        </member>
        <member name="M:CommandLineFluent.FluentParser.WriteOverallUsageAndHelp">
            <summary>
            Writes a summary of how you invoke the program and how you can obtain further help, by specifying a verb.
            It uses Config.GetUsageText and Config.GetHelpText.
            Same thing for Help Text.
            Does nothing if Config.WriteText is null.
            </summary>
        </member>
        <member name="M:CommandLineFluent.FluentParser.WriteUsageAndHelp(CommandLineFluent.IFluentVerb)">
            <summary>
            Writes the Usage Text, and then the Help Text for the specified verb. Order of priority is:
            verb.UsageText, then verb.UsageTextCreator, then the default HelpFormatter.FormatVerbUsage.
            Same thing for Help Text.
            Does nothing if Config.WriteText is null.
            </summary>
            <param name="verb">The verb to write detailed usage/help for</param>
        </member>
        <member name="T:CommandLineFluent.FluentParserBuilder">
            <summary>
            The starting point for setting up a FluentParser to parse command line arguments.
            Use the methods Configure, and either WithourVerbs or AddVerb to set this up.
            Once finished, use the method Build to validate and create a FluentParser.
            </summary>
        </member>
        <member name="M:CommandLineFluent.FluentParserBuilder.#ctor">
            <summary>
            Creates a new instance of FluentParserBuilder
            </summary>
        </member>
        <member name="M:CommandLineFluent.FluentParserBuilder.Configure(System.Action{CommandLineFluent.FluentParserConfig})">
            <summary>
            Configures the parser's options
            </summary>
        </member>
        <member name="M:CommandLineFluent.FluentParserBuilder.WithoutVerbs``1(System.Action{CommandLineFluent.FluentVerb{``0}})">
            <summary>
            Sets up how to parse without using verbs. Technically, this configures a default verb named "default", which
            is always used when parsing arguments. Arguments should not start with "default".
            </summary>
            <typeparam name="T">The type of the class which will be created when arguments are parsed successfully</typeparam>
        </member>
        <member name="M:CommandLineFluent.FluentParserBuilder.AddVerb``1(System.String,System.Action{CommandLineFluent.FluentVerb{``0}})">
            <summary>
            Adds a verb for this parser. The verb name dictates the text that has to be entered on the command line.
            e.g. "foo.exe add" invokes the verb with the name "add".
            </summary>
            <typeparam name="T">The type of the class which will be created when arguments for that verb are parsed successfully</typeparam>
            <param name="verbName">The name of the verb</param>
            <param name="verbConfig">The action to configure the verb</param>
        </member>
        <member name="M:CommandLineFluent.FluentParserBuilder.Build">
            <summary>
            Creates a FluentParser using the configuration of this FluentParserBuilder.
            Throws a FluentParserValidationException if anything or any verbs are improperly configured.
            </summary>
        </member>
        <member name="T:CommandLineFluent.FluentParserBuilderException">
            <summary>
            An exception that occured during setting up a FluentParserBuilder
            </summary>
        </member>
        <member name="M:CommandLineFluent.FluentParserBuilderException.#ctor">
            <summary>
            Creates a new instance of FluentParserBuilderException
            </summary>
        </member>
        <member name="M:CommandLineFluent.FluentParserBuilderException.#ctor(System.String)">
            <summary>
            Creates a new instance of FluentParserBuilderException
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:CommandLineFluent.FluentParserBuilderException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new instance of FluentParserBuilderException
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="innerException">The exception that is the cause of the current exception</param>
        </member>
        <member name="T:CommandLineFluent.FluentParserConfig">
            <summary>
            Configuration options affecting the behaviour of the FluentParser
            </summary>
        </member>
        <member name="P:CommandLineFluent.FluentParserConfig.ShortHelpSwitch">
            <summary>
            A special switch which will cause parsing to immediately stop and return a single Error: HelpRequested
            </summary>
        </member>
        <member name="P:CommandLineFluent.FluentParserConfig.LongHelpSwitch">
            <summary>
            A special switch which will cause parsing to immediately stop and return a single Error: HelpRequested
            </summary>
        </member>
        <member name="P:CommandLineFluent.FluentParserConfig.DefaultShortPrefix">
            <summary>
            Default prefix for all short names
            </summary>
        </member>
        <member name="P:CommandLineFluent.FluentParserConfig.DefaultLongPrefix">
            <summary>
            Default prefix for all long names
            </summary>
        </member>
        <member name="P:CommandLineFluent.FluentParserConfig.WriteText">
            <summary>
            The Action that will be invoked when writing Error, Help, or Usage text, with a newline
            </summary>
        </member>
        <member name="P:CommandLineFluent.FluentParserConfig.GetHelpText">
            <summary>
            The Action that will be invoked to get the Help text
            </summary>
        </member>
        <member name="P:CommandLineFluent.FluentParserConfig.GetUsageText">
            <summary>
            The Action that will be invoked to get the Usage text
            </summary>
        </member>
        <member name="P:CommandLineFluent.FluentParserConfig.GetErrorsText">
            <summary>
            The Action that will be invoked to create a human-readable string to display Errors to the user
            </summary>
        </member>
        <member name="P:CommandLineFluent.FluentParserConfig.MaxLineLength">
            <summary>
            Defines the maximum number of characters that can fit on one line when writing help/usage text
            </summary>
        </member>
        <member name="P:CommandLineFluent.FluentParserConfig.ExeceuteCommand">
            <summary>
            The command used to execute the program. Used when writing help text.
            </summary>
        </member>
        <member name="P:CommandLineFluent.FluentParserConfig.HelpText">
            <summary>
            Custom help text to be used when dispalying help information. This takes precedence over HelpTextCreator
            </summary>
        </member>
        <member name="P:CommandLineFluent.FluentParserConfig.UsageText">
            <summary>
            Custom help text to be used when dispalying help information. This takes precedence over UsageTextCreator
            </summary>
        </member>
        <member name="M:CommandLineFluent.FluentParserConfig.ConfigureWithDefaults">
            <summary>
            Configures to use a DefaultShortPrefix of -, a DefaultLongPrefix of --, Help switches of -? and --help,
            and Errors/Help/Usage is automatically written to Console.Write on any error, with a MaxLineLength of Console.WindowWidth.
            If the Console cannot be used, then WriteHelp and WriteUsage will be set to null and MaxLineLength will be set to 10,000
            </summary>
        </member>
        <member name="M:CommandLineFluent.FluentParserConfig.UseHelpSwitch(System.String,System.String)">
            <summary>
            Configures a special switch which, if encountered, will cause parsing to immediately stop and return a single Error, with the ErrorCode HelpRequested.
            Use this in conjunction with ShowUsageOnFailure/ShowHelpOnFailure to automatically show help.
            </summary>
            <param name="shortName">The short name. By default, -?</param>
            <param name="longName">The long name. By default, --help</param>
        </member>
        <member name="M:CommandLineFluent.FluentParserConfig.UseDefaultPrefixes(System.String,System.String)">
            <summary>
            Defines a short and long name prefix that will automatically be prepended to any non-null short and long names for any Options/Switches.
            By default, this is nothing.
            </summary>
            <param name="defaultShortPrefix">The prefix to apply to short names</param>
            <param name="defaultLongPrefix">The prefix to apply to long names</param>
            <returns></returns>
        </member>
        <member name="M:CommandLineFluent.FluentParserConfig.WithTextWriter(System.Action{System.String})">
            <summary>
            Defines the Action to invoke to write help, usage, and errors text. If null, this will be
            Console.Write
            </summary>
            <param name="textWriter">The Action</param>
        </member>
        <member name="M:CommandLineFluent.FluentParserConfig.WithExecuteCommand(System.String)">
            <summary>
            The command used to execute the program. Used when writing help text.
            If null, then the file name returned by System.Reflection.Assembly.GetEntryAssembly().Location will be used
            </summary>
        </member>
        <member name="M:CommandLineFluent.FluentParserConfig.ShowHelpAndUsageOnFailure">
            <summary>
            Configures the FluentParser to write default help and usage text on failure.
            It will be written will automatically upon an Error of any kind (including encountering the help switch).
            Usage is shown before Help.
            </summary>
        </member>
        <member name="M:CommandLineFluent.FluentParserConfig.ShowErrorsOnFailure(System.Func{System.Collections.Generic.IEnumerable{CommandLineFluent.Error},System.String})">
            <summary>
            Defines the action to invoke when any errors are encountered. By default, it will write Errors that should be shown to the user to Console.WriteLine (Message property).
            This Action will automatically be invoked upon an Error of any kind (including encountering the help switch).
            </summary>
            <param name="errorTextCreator">What is invoked to write Errors. If null, default formatting is used</param>
        </member>
        <member name="M:CommandLineFluent.FluentParserConfig.WithErrorFormatter(System.Func{System.Collections.Generic.IEnumerable{CommandLineFluent.Error},System.String})">
            <summary>
            Defines a custom errors text formatter, which returns the errors text to show to the user.
            </summary>
            <param name="errorTextCreator">What is invoked to write Errors. If null, Console.WriteLine</param>
        </member>
        <member name="M:CommandLineFluent.FluentParserConfig.WithHelpFormatter(System.Func{CommandLineFluent.FluentParser,System.String})">
            <summary>
            Defines a custom help text formatter, which returns the help text to show to the user.
            </summary>
            <param name="helpTextCreator">This takes an instance of this verb, and should return a string which is the help text</param>
        </member>
        <member name="M:CommandLineFluent.FluentParserConfig.WithUsageFormatter(System.Func{CommandLineFluent.FluentParser,System.String})">
            <summary>
            Defines a custom usage text creator, which returns the usage text to show to the user.
            </summary>
            <param name="usageTextCreator">This takes an instance of this verb, and should return a string which is the help text</param>
        </member>
        <member name="T:CommandLineFluent.FluentParserResult">
            <summary>
            The result of parsing some command line arguments
            </summary>
        </member>
        <member name="M:CommandLineFluent.FluentParserResult.OnSuccess``1(System.Action{``0})">
            <summary>
            If parsing was successful and the type that was parsed matches the type specified, invokes <paramref name="action"/>.
            </summary>
            <typeparam name="T">The type of the parsed class</typeparam>
        </member>
        <member name="M:CommandLineFluent.FluentParserResult.StopOnFailure">
            <summary>
            If the arguments failed to be parsed, returns null. Allows you to do Parse().StopOnFailure()?.OnSuccess() to stop the
            fluent callchain immediately when there are errors, saving unnecessary checks.
            </summary>
        </member>
        <member name="M:CommandLineFluent.FluentParserResult.OnFailure(System.Action{System.Collections.Generic.IReadOnlyCollection{CommandLineFluent.Error}})">
            <summary>
            If the arguments failed to be parsed, invokes <paramref name="action"/>.
            Generally you don't need to use this often, the help/usage text can tell the user what they did wrong.
            </summary>
            <param name="action">The action to take. If null, no action is taken</param>
        </member>
        <member name="M:CommandLineFluent.FluentParserResult.OnFailureAndStop(System.Action{System.Collections.Generic.IReadOnlyCollection{CommandLineFluent.Error}})">
            <summary>
            If the arguments failed to be parsed, invokes <paramref name="action"/> and returns null. Allows you to do Parse().OnFailureAndStop()?.OnSuccess()... to stop the
            fluent callchain immediately when there are errors, saving some unnecessary checks.
            Generally you don't need to use this often, the help/usage text can tell the user what they did wrong.
            </summary>
            <param name="action">The action to take. If null, no action is taken</param>
        </member>
        <member name="T:CommandLineFluent.FluentParserResultAwaitable">
            <summary>
            The result of parsing some command line arguments.
            Designed for invoking awaitable actions. Use this the same way you would the FluentParserResult,
            except at the end of the fluent callchain, call .Invoke() or .InvokeAsync() and await the returned Task.
            </summary>
        </member>
        <member name="P:CommandLineFluent.FluentParserResultAwaitable.Action">
            <summary>
            The Func that will be invoked on calling .Invoke() or .InvokeAsync(), which calls the correct Func supplied by OnSuccess() or OnFailure().
            </summary>
        </member>
        <member name="M:CommandLineFluent.FluentParserResultAwaitable.OnSuccess``1(System.Func{``0,System.Threading.Tasks.Task})">
            <summary>
            If parsing was successful and the type that was parsed matches the type specified, then <paramref name="action"/> will
            be run upon calling .Invoke() or .InvokeAsync()
            </summary>
            <typeparam name="T">The type of the parsed class</typeparam>
        </member>
        <member name="M:CommandLineFluent.FluentParserResultAwaitable.OnFailure(System.Func{System.Collections.Generic.IReadOnlyCollection{CommandLineFluent.Error},System.Threading.Tasks.Task})">
            <summary>
            If the arguments failed to be parsed, invokes <paramref name="action"/> on calling .Invoke().
            Generally you don't need to use this often, the help/usage text can tell the user what they did wrong.
            </summary>
            <param name="action">The action to take. If null, no action is taken</param>
        </member>
        <member name="M:CommandLineFluent.FluentParserResultAwaitable.StopOnFailure">
            <summary>
            If the arguments failed to be parsed, returns null. Allows you to do Parse().StopOnFailure()?.OnSuccess() to stop the
            fluent callchain immediately when there are errors, saving unnecessary checks.
            It's not recommended you use this, because this will make awaiting the Task returned by Invoke() or InvokeAsync() trickier, since
            you need to check for null before awaiting.
            </summary>
        </member>
        <member name="M:CommandLineFluent.FluentParserResultAwaitable.Invoke">
            <summary>
            Invokes the Action specified by the relevant OnSuccess() call, and returns the resultant Task
            </summary>
        </member>
        <member name="M:CommandLineFluent.FluentParserResultAwaitable.InvokeAsync">
            <summary>
            Invokes the Action specified by the relevant OnSuccess() call, and awaits the resultant Task
            </summary>
        </member>
        <member name="T:CommandLineFluent.FluentParserResultBase">
            <summary>
            The result of parsing some command line arguments
            </summary>
        </member>
        <member name="P:CommandLineFluent.FluentParserResultBase.Errors">
            <summary>
            Any errors encountered when parsing
            </summary>
        </member>
        <member name="P:CommandLineFluent.FluentParserResultBase.ParsedVerb">
            <summary>
            The verb that was parsed
            </summary>
        </member>
        <member name="P:CommandLineFluent.FluentParserResultBase.Success">
            <summary>
            Whether or not parsing was successful
            </summary>
        </member>
        <member name="M:CommandLineFluent.FluentParserResultBase.GetParsedObject``1">
            <summary>
            If parsing was successful and the type that was parsed matches the type specified, returns the object that was parsed.
            Otherwise, returns the default value for type <typeparamref name="T"/>
            </summary>
            <typeparam name="T">The type of the parsed class</typeparam>
        </member>
        <member name="T:CommandLineFluent.FluentParserValidationException">
            <summary>
            An exception that occurred when validating that a FluentParserBuilder was set up correctly.
            </summary>
        </member>
        <member name="P:CommandLineFluent.FluentParserValidationException.Errors">
            <summary>
            Errors encountered upon validation
            </summary>
        </member>
        <member name="M:CommandLineFluent.FluentParserValidationException.#ctor">
            <summary>
            Creates a new instance of FluentParserValidationException
            </summary>
        </member>
        <member name="M:CommandLineFluent.FluentParserValidationException.#ctor(System.String)">
            <summary>
            Creates a new instance of FluentParserValidationException
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:CommandLineFluent.FluentParserValidationException.#ctor(System.String,System.Collections.Generic.ICollection{CommandLineFluent.Error})">
            <summary>
            Creates a new instance of FluentParserValidationException
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="errors">The errors encountered upon validation</param>
        </member>
        <member name="M:CommandLineFluent.FluentParserValidationException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new instance of FluentParserValidationException
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="innerException">The exception that is the cause of the current exception</param>
        </member>
        <member name="M:CommandLineFluent.FluentParserValidationException.#ctor(System.String,System.Collections.Generic.ICollection{CommandLineFluent.Error},System.Exception)">
            <summary>
            Creates a new instance of FluentParserValidationException
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="errors">The errors encountered upon validation</param>
            <param name="innerException">The exception that is the cause of the current exception</param>
        </member>
        <member name="T:CommandLineFluent.FluentVerb`1">
            <summary>
            A single verb, for example, foo.exe add.
            Verbs have their own Options, Values, and Switches which they can parse and create an instance of <typeparamref name="T"/>
            </summary>
        </member>
        <member name="P:CommandLineFluent.FluentVerb`1.FluentManyValues">
            <summary>
            An indeterminate number of values
            </summary>
        </member>
        <member name="P:CommandLineFluent.FluentVerb`1.FluentValues">
            <summary>
            All Values which have been added to this verb
            </summary>
        </member>
        <member name="P:CommandLineFluent.FluentVerb`1.FluentSwitches">
            <summary>
            All Switches which have been added to this verb
            </summary>
        </member>
        <member name="P:CommandLineFluent.FluentVerb`1.FluentOptions">
            <summary>
            All Options which have been added to this verb
            </summary>
        </member>
        <member name="P:CommandLineFluent.FluentVerb`1.HelpTextCreator">
            <summary>
            The custom function to use when displaying help information, if HelpText is null.
            </summary>
        </member>
        <member name="P:CommandLineFluent.FluentVerb`1.UsageTextCreator">
            <summary>
            The custom function to use when displaying usage information, if UsageText is null.
            </summary>s
        </member>
        <member name="P:CommandLineFluent.FluentVerb`1.ParsedObject">
            <summary>
            The object that the verb has successfully parsed. If no object has been parsed yet, this is the default
            value for an object of type <typeparamref name="T"/>. This is also reset to default when Reset is invoked.
            </summary>
        </member>
        <member name="P:CommandLineFluent.FluentVerb`1.TargetType">
            <summary>
            The type of the object that this verb will provide the parsed the arguments to
            </summary>
        </member>
        <member name="P:CommandLineFluent.FluentVerb`1.Name">
            <summary>
            The name used to invoke the verb. This must be unique.
            </summary>
        </member>
        <member name="P:CommandLineFluent.FluentVerb`1.HelpText">
            <summary>
            Human-readable text that provides a description as to what this verb is used for. This is used when displaying Help.
            </summary>
        </member>
        <member name="P:CommandLineFluent.FluentVerb`1.Description">
            <summary>
            Human-readable text that provides a description as to what this verb is used for. This is used when displaying Help.
            </summary>
        </member>
        <member name="P:CommandLineFluent.FluentVerb`1.Successful">
            <summary>
            True if the last parsing attempt was successful, false if it was unsuccessful. Null if the verb was not parsed.
            This is automatically reset each time you invoke Parse on a FluentParser that owns this verb
            </summary>
        </member>
        <member name="M:CommandLineFluent.FluentVerb`1.Validate">
            <summary>
            Returns errors if improperly configured, or an empty collection if all is well
            </summary>
        </member>
        <member name="M:CommandLineFluent.FluentVerb`1.Reset">
            <summary>
            Clears the Verb's parsed instance and sets Successful to null.
            </summary>
        </member>
        <member name="M:CommandLineFluent.FluentVerb`1.WithHelpText(System.String)">
            <summary>
            The help text to be used when dispalying help information.
            </summary>
            <param name="helpText">The help text</param>
        </member>
        <member name="M:CommandLineFluent.FluentVerb`1.WithDescription(System.String)">
            <summary>
            Configures a description for this verb. This is used, by default, when writing help/usage information
            when the user did not specify a verb.
            </summary>
            <param name="description">The description</param>
        </member>
        <member name="M:CommandLineFluent.FluentVerb`1.WithHelpFormatter(System.Func{CommandLineFluent.IFluentVerb,System.String})">
            <summary>
            Configures a custom help text creator
            </summary>
            <param name="helpTextCreator">This takes an instance of this verb, and should return a string which is the help text</param>
        </member>
        <member name="M:CommandLineFluent.FluentVerb`1.WithUsageFormatter(System.Func{CommandLineFluent.IFluentVerb,System.String})">
            <summary>
            Configures a custom usage text creator
            </summary>
            <param name="usageTextCreator">This takes an instance of this verb, and should return a string which is the help text</param>
        </member>
        <member name="M:CommandLineFluent.FluentVerb`1.AddOption(System.String,System.String)">
            <summary>
            Creates a new Option and adds it to this verb. Its plain text value will be assigned to the target property.
            Either <paramref name="shortName"/> or <paramref name="longName"/> can be null to not use a short or long name, but both cannot be null.
            </summary>
            <param name="shortName">The short name for the Option</param>
            <param name="longName">The long name for the Option</param>
        </member>
        <member name="M:CommandLineFluent.FluentVerb`1.AddOption``1(System.String,System.String)">
            <summary>
            Creates a new Option and adds it to this verb. A converted value will be assigned to the target property,
            based on the converter with which the Option is configured.
            Either <paramref name="shortName"/> or <paramref name="longName"/> can be null to not use a short or long name, but both cannot be null.
            </summary>
            <param name="shortName">The short name for the Option</param>
            <param name="longName">The long name for the Option</param>
        </member>
        <member name="M:CommandLineFluent.FluentVerb`1.AddValue">
            <summary>
            Creates a new Value and adds it to this verb. Its plain text value will be assigned to the target property.
            The order in which you add Values determines which properties get what values. The first Value added will use the first
            value found in the arguments, the second Value will get the next, etc.
            </summary>
        </member>
        <member name="M:CommandLineFluent.FluentVerb`1.AddValue``1">
            <summary>
            Creates a new Value and adds it to this verb. A converted value will be assigned to the target property,
            based on the converter with which the Value is configured.
            The order in which you add Values determines which properties get what values. The first Value added will use the first
            value found in the arguments, the second Value will get the next, etc.
            </summary>
        </member>
        <member name="M:CommandLineFluent.FluentVerb`1.AddManyValues">
            <summary>
            Creates a new Values and adds it to this verb. This Values will accept all arguments as plain text not recognizd as an Option or Switch as a Value.
            Be careful using this, anything not otherwise recognized as an Option or Switch will be parsed as a Value!
            You may want to call IgnorePrefixes as well, so it isn't too greedy.
            </summary>
        </member>
        <member name="M:CommandLineFluent.FluentVerb`1.AddManyValues``1">
            <summary>
            Creates a new Values and adds it to this verb. This Values will accept all converted arguments not recognizd as an Option or Switch as a Value.
            Be careful using this, anything not otherwise recognized as an Option or Switch will be parsed as a Value!
            You may want to call IgnorePrefixes as well, so it isn't too greedy.
            </summary>
        </member>
        <member name="M:CommandLineFluent.FluentVerb`1.AddSwitch(System.String,System.String)">
            <summary>
            Creates a new Switch and adds it to this verb. True or False will be assigned to the target property,
            depending on whether or not the Switch is present
            Either <paramref name="shortName"/> or <paramref name="longName"/> can be null to not use a short or long name, but both cannot be null.
            </summary>
            <param name="shortName">The short name for the Switch</param>
            <param name="longName">The long name for the Switch</param>
        </member>
        <member name="M:CommandLineFluent.FluentVerb`1.AddSwitch``1(System.String,System.String)">
            <summary>
            Creates a new Switch and adds it to this verb. A converted value will be assigned to the target property,
            based on the converter with which the Switch is configured.
            Either <paramref name="shortName"/> or <paramref name="longName"/> can be null to not use a short or long name, but both cannot be null.
            </summary>
            <param name="shortName">The short name for the Switch</param>
            <param name="longName">The long name for the Switch</param>
        </member>
        <member name="M:CommandLineFluent.FluentVerb`1.Parse(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Parses the provided arguments using this Verb's rules. The verb's name should not be the first element of <paramref name="args"/>.
            Please check this and if necessary, skip the first one before invoking this.
            </summary>
            <param name="args">The arguments to parse</param>
        </member>
        <member name="M:CommandLineFluent.FluentVerb`1.Option(System.String,`0,System.String)">
            <summary>
            Sets the property of <paramref name="target"/> to the value of <paramref name="value"/> (which may be converted first).
            </summary>
            <param name="name">The name of the Option which will set the property of <paramref name="target"/></param>
            <param name="target">The object whose property will be set</param>
            <param name="value">The value to provide to the property, which the Option may convert</param>
        </member>
        <member name="M:CommandLineFluent.FluentVerb`1.Switch(System.String,`0,System.Boolean)">
            <summary>
            Sets the property of <paramref name="target"/> to the value of <paramref name="value"/> (which may be converted first).
            </summary>
            <param name="name">The name of the Switch which will set the property of <paramref name="target"/></param>
            <param name="target">The object whose property will be set</param>
            <param name="value">The value to provide to the property, which the Switch may convert</param>
        </member>
        <member name="M:CommandLineFluent.FluentVerb`1.Values(`0,System.String[])">
            <summary>
            Sets the properties of <paramref name="target"/> to the values of <paramref name="values"/> (which may be converted first).
            If ManyValues were configured, all of <paramref name="values"/> will be accepted. If not, and the length of <paramref name="values"/> is more than
            the number of configured Values, an Error is returned. If the length of <paramref name="values"/> is less than the number of configured Values,
            the remaining configured Values are assigned null, which may result in an Error if they are required.
            </summary>
            <param name="target">The object whose properties will be set</param>
            <param name="values">The values to provide to the property, which the Value or Values may convert</param>
        </member>
        <member name="M:CommandLineFluent.FluentVerb`1.PrefixAndCheckAndMap(System.String@,System.String@,CommandLineFluent.Arguments.FluentArgumentType)">
            <summary>
            Makes sure that at least one of shortName and longName is not null, that they are not empty or whitespace, 
            applies any prefixes required, and adds them to our map to ensure they're unique.
            </summary>
            <param name="shortName">The short name</param>
            <param name="longName">The long name</param>
            <param name="type">The type of the FluentArgument</param>
        </member>
        <member name="T:CommandLineFluent.HelpFormatter">
            <summary>
            Provides default usage and help formatting
            </summary>
        </member>
        <member name="M:CommandLineFluent.HelpFormatter.FormatOverallUsage(System.Collections.Generic.IEnumerable{CommandLineFluent.IFluentVerb},System.String)">
            <summary>
            Formats the overall usage, given the command which defines how you execute this program.
            </summary>
            <param name="verbs">The verbs whose names will be used</param>
            <param name="execeuteCommand">The command to execute this program, or null to omit it</param>
        </member>
        <member name="M:CommandLineFluent.HelpFormatter.FormatOverallHelp(System.Collections.Generic.IEnumerable{CommandLineFluent.IFluentVerb},System.String,System.Int32)">
            <summary>
            Formats the overall help.
            Lists all verbs and their description.
            </summary>
            <param name="verbs">The verbs whose descriptions will be used</param>
            <param name="helpSwitches">A human-readable string showing the short and long help switches</param>
            <param name="maxLineLength">The maximum line length. If exceeded, an extra line break will be added</param>
        </member>
        <member name="M:CommandLineFluent.HelpFormatter.FormatVerbHelp(CommandLineFluent.IFluentVerb,System.Int32)">
            <summary>
            Formats the help text of the Options, Switches, and Values of the verb. If custom HelpText has been provided, that will be used.
            If not, then if custom HelpFormatter is set on the verb, that is used to produce the help text. Otherwise, default formatting is used.
            </summary>
        </member>
        <member name="M:CommandLineFluent.HelpFormatter.FormatVerbUsage(CommandLineFluent.IFluentVerb,System.String)">
            <summary>
            Formats the usage text of the Options, Switches, and Values of the verb.
            Usage is formatted by writing the executeCommand, followed by the verb's Name,
            </summary>
            <param name="verb">The verb to write Usage information for</param>
            <param name="executeCommand">The command used to invoke the program</param>
        </member>
        <member name="M:CommandLineFluent.HelpFormatter.FormatErrors(System.Collections.Generic.IEnumerable{CommandLineFluent.Error})">
            <summary>
            Returns the Error.Message, if Error.ShouldBeShownToUser is true. One Message per line.
            </summary>
            <param name="errors">The errors</param>
        </member>
        <member name="T:CommandLineFluent.IFluentVerb">
            <summary>
            A single verb, for example, foo.exe add.
            Verbs have their own Options, Values, and Switches which they can parse and create an instance of a particular class.
            </summary>
        </member>
        <member name="P:CommandLineFluent.IFluentVerb.FluentManyValues">
            <summary>
            An indeterminate number of values
            </summary>
        </member>
        <member name="P:CommandLineFluent.IFluentVerb.FluentValues">
            <summary>
            All Values which have been added to this verb
            </summary>
        </member>
        <member name="P:CommandLineFluent.IFluentVerb.FluentSwitches">
            <summary>
            All Switches which have been added to this verb
            </summary>
        </member>
        <member name="P:CommandLineFluent.IFluentVerb.FluentOptions">
            <summary>
            All Options which have been added to this verb
            </summary>
        </member>
        <member name="P:CommandLineFluent.IFluentVerb.HelpTextCreator">
            <summary>
            The custom function to use when displaying help information, if HelpText is null.
            </summary>
        </member>
        <member name="P:CommandLineFluent.IFluentVerb.UsageTextCreator">
            <summary>
            The custom function to use when displaying usage information, if UsageText is null.
            </summary>s
        </member>
        <member name="P:CommandLineFluent.IFluentVerb.Name">
            <summary>
            The name used to invoke the verb. This must be unique.
            </summary>
        </member>
        <member name="P:CommandLineFluent.IFluentVerb.HelpText">
            <summary>
            Human-readable text that provides a description as to what this verb is used for. This is used when displaying Help.
            </summary>
        </member>
        <member name="P:CommandLineFluent.IFluentVerb.Description">
            <summary>
            Human-readable text that provides a description as to what this verb is used for. This is used when displaying Help.
            </summary>
        </member>
        <member name="P:CommandLineFluent.IFluentVerb.Successful">
            <summary>
            True if the last parsing attempt was successful, false if it was unsuccessful. Null if the verb was not parsed.
            This is automatically reset each time you invoke Parse on a FluentParser that owns this verb
            </summary>
        </member>
        <member name="M:CommandLineFluent.IFluentVerb.Reset">
            <summary>
            Clears the Verb's parsed instance and sets Successful to null.
            </summary>
        </member>
        <member name="P:CommandLineFluent.IFluentVerb.TargetType">
            <summary>
            The type of the object that this verb will provide the parsed the arguments to
            </summary>
        </member>
        <member name="M:CommandLineFluent.IFluentVerb.Validate">
            <summary>
            Returns errors if improperly configured, or null if all is well
            </summary>
        </member>
        <member name="M:CommandLineFluent.IFluentVerb.Parse(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Parses the provided arguments using this verb's rules. You shouldn't need to use this directly. But if you do,
            the first argument should not be this verb's name; if it is, make sure to use .Skip(1) first.
            </summary>
            <param name="args">The arguments to parse</param>
        </member>
        <member name="T:CommandLineFluent.Util">
            <summary>
            Utility methods
            </summary>
        </member>
        <member name="M:CommandLineFluent.Util.ShortAndLongName(CommandLineFluent.Arguments.IFluentOption)">
            <summary>
            Makes a string like: -s|--long, to show the user both ways of writing the switch
            </summary>
        </member>
        <member name="M:CommandLineFluent.Util.ShortAndLongName(CommandLineFluent.Arguments.IFluentSwitch)">
            <summary>
            Makes a string like: -s|--long, to show the user both ways of writing the switch
            </summary>
        </member>
        <member name="M:CommandLineFluent.Util.ShortAndLongName(System.String,System.String)">
            <summary>
            Makes a string like: -s|--long, to show the user both ways of writing the switch
            </summary>
        </member>
        <member name="M:CommandLineFluent.Util.PropertyInfoFromExpression``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Given an Expression, returns the corresponding Property. Throws an exception if <paramref name="expression"/> is not a MemberExpression
            which references an object property
            </summary>
            <typeparam name="T">Argument which is passed to the expression</typeparam>
            <typeparam name="C">What the expression returns</typeparam>
            <param name="expression">The expression to convert into a PropertyInfo</param>
        </member>
        <member name="T:CommandLineFluent.Validation.Validators">
            <summary>
            Has some commonly-used validators. For those that just take one string, you can do this:
            verb.WithValidator(Validators.FileExists)
            </summary>
        </member>
        <member name="M:CommandLineFluent.Validation.Validators.FileExists(System.String)">
            <summary>
            Makes sure the provided path is a file that exists.
            Equivalent to returning null on File.Exists(path) == true
            </summary>
            <param name="path">The path to check</param>
        </member>
        <member name="M:CommandLineFluent.Validation.Validators.DirectoryExists(System.String)">
            <summary>
            Makes sure the provided path is a directory that exists.
            Equivalent to returning null on Directory.Exists(path) == true
            </summary>
            <param name="path">The path to check</param>
        </member>
    </members>
</doc>
